@using ModelingEvolution.BlazorPerfMon.Client.Services
@using ModelingEvolution.BlazorPerfMon.Client.Rendering
@using ModelingEvolution.BlazorPerfMon.Client.Collections
@using ModelingEvolution.BlazorPerfMon.Client.Models
@using ModelingEvolution.BlazorPerfMon.Client.Extensions
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using Microsoft.AspNetCore.Components.Web
@using ModelingEvolution
@implements IAsyncDisposable

<div class="monitor-container">
    <div class="status-circle @GetStatusClass()"></div>
    <SKCanvasView @ref="_canvasView" OnPaintSurface="OnPaintSurface" IgnorePixelScaling="false" EnableRenderLoop="true" />
</div>

<style>
    .monitor-container {
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        margin: 0;
        padding: 0;
        position: relative;
        overflow: hidden;
    }

    .status-circle {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        z-index: 1000;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    .status-green {
        background: #4caf50;
    }

    .status-yellow {
        background: #ffeb3b;
    }

    .status-red {
        background: #f44336;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>

@code {
    [Inject] private WebSocketClient WebSocketClient { get; set; } = default!;
    [Inject] private MetricsStore MetricsStore { get; set; } = default!;

    /// <summary>
    /// WebSocket server URL to connect to. If null, uses the default from WebSocketClient configuration.
    /// </summary>
    [Parameter] public string? ServerUrl { get; set; }

    /// <summary>
    /// Whether to show the connection status indicator (default: true).
    /// </summary>
    [Parameter] public bool ShowStatusIndicator { get; set; } = true;

    /// <summary>
    /// Background color for the monitor canvas (default: #1a1a1a).
    /// </summary>
    [Parameter] public string BackgroundColor { get; set; } = "#1a1a1a";

    private SKCanvasView? _canvasView;
    private List<LayoutGridItem> _gridItems = new();

    private bool _isConnected;
    private uint _latestCollectionTimeMs;
    private string _currentStatusClass = "status-red";
    private PeriodicTimer? _scaleUpdateTimer;
    private Task? _scaleUpdateTask;

    // Configuration
    private PerformanceConfigurationSnapshot? _configuration;
    private int _timeWindowMs = 60000; // Default 60 seconds
    private int _collectionIntervalMs = 500; // Default 500ms

    // Shared timestamp accessor for all time-series charts
    private SampleAccessor<uint>? _timestampAccessor;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to WebSocket events
        WebSocketClient.OnConfigurationReceived += OnConfigurationReceived;
        WebSocketClient.OnMetricsReceived += OnMetricsReceived;
        WebSocketClient.OnConnectionStateChanged += OnConnectionStateChanged;

        // Subscribe to metrics store updates
        MetricsStore.OnMetricsUpdated += OnMetricsUpdated;

        // Connect to WebSocket
        await WebSocketClient.ConnectAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _canvasView != null)
        {
            // Start scale update timer (every 5 seconds)
            _scaleUpdateTimer = new PeriodicTimer(TimeSpan.FromSeconds(5));
            _scaleUpdateTask = ScaleUpdateLoop();
        }
    }

    private async Task ScaleUpdateLoop()
    {
        if (_scaleUpdateTimer == null) return;

        try
        {
            while (await _scaleUpdateTimer.WaitForNextTickAsync())
            {
                // Update dynamic scale for all time-series charts (Network and Disk)
                foreach (var gridItem in _gridItems)
                {
                    if (gridItem.Chart is NetworkChart networkChart)
                    {
                        // Access the internal TimeSeriesChart through reflection or add UpdateDynamicScale to IChart
                        // For now, skip - will be handled by the chart itself
                    }
                    else if (gridItem.Chart is DiskChart diskChart)
                    {
                        // Same as above
                    }
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Timer disposed
        }
    }

    private void OnConfigurationReceived(PerformanceConfigurationSnapshot configuration)
    {
        _configuration = configuration;
        _collectionIntervalMs = (int)configuration.CollectionIntervalMs;
        _timeWindowMs = (int)(configuration.DataPointsToKeep * configuration.CollectionIntervalMs);

        // Create shared timestamp accessor
        var emptyBuffer = new ImmutableCircularBuffer<MetricSample>(1);
        _timestampAccessor = new SampleAccessor<uint>(emptyBuffer, sample => sample.CreatedAt);

        // Clear existing grid items
        _gridItems.Clear();

        // Build grid items from layout
        if (configuration.Layout != null && configuration.Layout.Length > 0)
        {
            int totalRows = configuration.Layout.Length;

            for (int row = 0; row < configuration.Layout.Length; row++)
            {
                var rowSources = configuration.Layout[row];
                int colsInRow = rowSources.Length;

                for (int col = 0; col < rowSources.Length; col++)
                {
                    var source = rowSources[col];
                    var chart = CreateChart(source);

                    if (chart != null)
                    {
                        _gridItems.Add(new LayoutGridItem
                        {
                            Row = row,
                            Col = col,
                            TotalRows = totalRows,
                            ColsInRow = colsInRow,
                            Source = source,
                            Chart = chart
                        });
                    }
                }
            }
        }

        Console.WriteLine($"Configuration received: {_gridItems.Count} charts created, {_timeWindowMs}ms window");
    }

    private IChart? CreateChart(MetricSource source)
    {
        float intervalSec = _collectionIntervalMs / 1000f;

        return source.Name switch
        {
            "CPU" when source.Identifier == null => new CpuBarChart((int)source.Count),
            "GPU" when source.Identifier == null => new GpuBarChart((int)source.Count),
            "ComputeLoad" => new ComputeLoadChart(_timeWindowMs, _timestampAccessor!),
            "Network" when !string.IsNullOrEmpty(source.Identifier) =>
                new NetworkChart(source.Identifier, intervalSec, _timeWindowMs, _timestampAccessor!),
            "Disk" when !string.IsNullOrEmpty(source.Identifier) =>
                new DiskChart(source.Identifier, intervalSec, _timeWindowMs, _timestampAccessor!),
            _ => null
        };
    }


    private void OnMetricsReceived(MetricSample sample)
    {
        MetricsStore.AddSample(sample);
        _latestCollectionTimeMs = sample.CollectionDurationMs;

        // Only update UI if status changed
        var newStatus = CalculateStatusClass();
        if (newStatus != _currentStatusClass)
        {
            _currentStatusClass = newStatus;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnConnectionStateChanged(bool isConnected)
    {
        _isConnected = isConnected;

        // Connection state change always affects status
        var newStatus = CalculateStatusClass();
        if (newStatus != _currentStatusClass)
        {
            _currentStatusClass = newStatus;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnMetricsUpdated()
    {
        // Data updated, canvas will be refreshed by render loop
    }

    private string GetStatusClass() => ShowStatusIndicator ? _currentStatusClass : "";

    private string CalculateStatusClass()
    {
        if (!_isConnected)
            return "status-red";

        return _latestCollectionTimeMs < _collectionIntervalMs ? "status-green" : "status-yellow";
    }

    private void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        var canvas = e.Surface.Canvas;
        canvas.Clear();

        var bounds = new SKRect(0, 0, e.Info.Width, e.Info.Height);

        // Wait for configuration before rendering
        if (_configuration == null || _gridItems.Count == 0)
        {
            return;
        }

        // Get current buffer once for time-consistent rendering
        var buffer = MetricsStore.GetBuffer();
        if (buffer.Count == 0)
            return;

        // Update timestamp accessor shared by all time-series charts
        _timestampAccessor?.UpdateBuffer(buffer);

        // Update all charts with the same buffer snapshot
        foreach (var gridItem in _gridItems)
        {
            gridItem.Chart.UpdateBuffer(buffer);
        }

        // Render all charts using dynamic grid layout
        foreach (var gridItem in _gridItems)
        {
            var cellBounds = gridItem.Arrange(bounds);
            var cellSize = new SKSize(cellBounds.Width, cellBounds.Height);

            canvas.Save();
            canvas.Translate(cellBounds.Left, cellBounds.Top);
            gridItem.Chart.Render(canvas, cellSize);
            canvas.Restore();
        }
    }


    public async ValueTask DisposeAsync()
    {
        // Stop scale update timer
        _scaleUpdateTimer?.Dispose();
        if (_scaleUpdateTask != null)
        {
            try
            {
                await _scaleUpdateTask;
            }
            catch { }
        }

        if (WebSocketClient != null)
        {
            WebSocketClient.OnConfigurationReceived -= OnConfigurationReceived;
            WebSocketClient.OnMetricsReceived -= OnMetricsReceived;
            WebSocketClient.OnConnectionStateChanged -= OnConnectionStateChanged;
            await WebSocketClient.DisposeAsync();
        }

        if (MetricsStore != null)
        {
            MetricsStore.OnMetricsUpdated -= OnMetricsUpdated;
        }

        // Note: IChart interface doesn't implement IDisposable
        // If charts need disposal, we'd need to add it to the interface
        _gridItems.Clear();
    }
}
